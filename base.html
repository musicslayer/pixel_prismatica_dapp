<!DOCTYPE html>


<style>
    .column {
    float: left;
    
    }
	
	.row:after {
    content: "";
    display: table;
    clear: both;
    }
</style>

<h1 id="ID_HeaderText"></h1>

<a href="https://musicslayer.github.io/pixel_prismatica_dapp/" target="_parent">Select a different network.</a>

<h2><u>Connection</u></h2>

<text>Connect your wallet to this dapp to interact with it. MetaMask and Trust Wallet DApp Browser are supported.</text><br/><br/>
<img src="metamask.png" alt="MetaMask Logo" style="width:32px;height:32px;">
<img src="trust_wallet.png" alt="Trust Wallet Logo" style="width:32px;height:32px;"><br/><br/>
<button id="ID_ConnectButton">Connect</button>

<p id="ID_ConnectAddressResultText" style='white-space: pre;'>Address Connected: ?</p>
<table id="ID_ConnectAddressResultTable"></table>

<br/><br/><br/>

<h2><u>Minting</u></h2>
<text id="ID_UpdateMintDataResultText">?</text>
<button id="ID_UpdateMintDataButton">Refresh</button><br/><br/>
<button id="ID_MintButton">Mint NFT</button><br/>

<br/>

<div class="row">
<div class="column">
<text>Color Mode:</text><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode0" value="0" checked="checked">
<label for="ID_XRadioColorMode0">Rainbow Light</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode1" value="1">
<label for="ID_XRadioColorMode1">Rainbow Dark</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode2" value="2">
<label for="ID_XRadioColorMode2">Monochrome</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode3" value="3">
<label for="ID_XRadioColorMode3">Red</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode4" value="4">
<label for="ID_XRadioColorMode4">Green</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode5" value="5">
<label for="ID_XRadioColorMode5">Blue</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode6" value="6">
<label for="ID_XRadioColorMode6">Green & Blue</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode7" value="7">
<label for="ID_XRadioColorMode7">Red & Green</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode8" value="8">
<label for="ID_XRadioColorMode8">Red & Blue</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode9" value="9">
<label for="ID_XRadioColorMode9">Cyan</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode10" value="10">
<label for="ID_XRadioColorMode10">Yellow</label><br/>
<input type="radio" name="xcolor_mode" id="ID_XRadioColorMode11" value="11">
<label for="ID_XRadioColorMode11">Magenta</label><br/>
</div>

<div class="column"> <!-- For spacing -->
<text>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</text>
</div>

<div class="column">
<text>Animation Duration:</text><br/>
<input type="radio" name="xduration" id="ID_XRadioDuration0" value="0">
<label for="ID_XRadioDuration0">Short</label><br/>
<input type="radio" name="xduration" id="ID_XRadioDuration1" value="1" checked="checked">
<label for="ID_XRadioDuration1">Medium</label><br/>
<input type="radio" name="xduration" id="ID_XRadioDuration2" value="2">
<label for="ID_XRadioDuration2">Long</label><br/>
</div>

<div class="column"> <!-- For spacing -->
<text>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</text>
</div>

<div class="column">
<text>Image Size:</text><br/>
<input type="radio" name="ximage_size" id="ID_XRadioImageSize0" value="0">
<label for="ID_XRadioImageSize0">Small</label><br/>
<input type="radio" name="ximage_size" id="ID_XRadioImageSize1" value="1" checked="checked">
<label for="ID_XRadioImageSize1">Medium</label><br/>
<input type="radio" name="ximage_size" id="ID_XRadioImageSize2" value="2">
<label for="ID_XRadioImageSize2">Large <font color="#B00000">(Not displayed in some wallets/marketplaces)</font></label><br/>
</div>
</div>

<p id="ID_MintResultText" style='white-space: pre;'></p>

<br/><br/><br/>

<h2><u>Change Configuration</u></h2>

<text>ID:</text>
<input id="ID_ConfigIDInput" type="text" maxlength="9"></input>
<button id="ID_SaveConfigButton">Save Configuration</button><br/>
<br/>

<div class="row">
<div class="column">
<text>Color Mode:</text><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode0" value="0" checked="checked">
<label for="ID_RadioColorMode0">Rainbow Light</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode1" value="1">
<label for="ID_RadioColorMode1">Rainbow Dark</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode2" value="2">
<label for="ID_RadioColorMode2">Monochrome</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode3" value="3">
<label for="ID_RadioColorMode3">Red</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode4" value="4">
<label for="ID_RadioColorMode4">Green</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode5" value="5">
<label for="ID_RadioColorMode5">Blue</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode6" value="6">
<label for="ID_RadioColorMode6">Green & Blue</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode7" value="7">
<label for="ID_RadioColorMode7">Red & Green</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode8" value="8">
<label for="ID_RadioColorMode8">Red & Blue</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode9" value="9">
<label for="ID_RadioColorMode9">Cyan</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode10" value="10">
<label for="ID_RadioColorMode10">Yellow</label><br/>
<input type="radio" name="color_mode" id="ID_RadioColorMode11" value="11">
<label for="ID_RadioColorMode11">Magenta</label><br/>
</div>

<div class="column"> <!-- For spacing -->
<text>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</text>
</div>

<div class="column">
<text>Animation Duration:</text><br/>
<input type="radio" name="duration" id="ID_RadioDuration0" value="0"
<label for="ID_RadioDuration0">Short</label><br/>
<input type="radio" name="duration" id="ID_RadioDuration1" value="1" checked="checked">
<label for="ID_RadioDuration1">Medium</label><br/>
<input type="radio" name="duration" id="ID_RadioDuration2" value="2">
<label for="ID_RadioDuration2">Long</label><br/>
</div>

<div class="column"> <!-- For spacing -->
<text>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</text>
</div>

<div class="column">
<text>Image Size:</text><br/>
<input type="radio" name="image_size" id="ID_RadioImageSize0" value="0">
<label for="ID_RadioImageSize0">Small</label><br/>
<input type="radio" name="image_size" id="ID_RadioImageSize1" value="1" checked="checked">
<label for="ID_RadioImageSize1">Medium</label><br/>
<input type="radio" name="image_size" id="ID_RadioImageSize2" value="2">
<label for="ID_RadioImageSize2">Large <font color="#B00000">(Not displayed in some wallets/marketplaces)</font></label><br/>
</div>
</div>

<p id="ID_SaveConfigResultText" style='white-space: pre;'></p>

<br/><br/><br/>

<h2><u>View NFT</u></h2>
<text>ID:</text>
<input id="ID_NFTIDInput" type="text" maxlength="9"></input>
<button id="ID_NFTDisplayButton">View</button><br/>
<p id="ID_NFTOwnerText" style='white-space: pre;'>Owner: ?</p>
<img id="ID_NFTImage" src=""/>
<p id="ID_NFTDisplayResultText" style='white-space: pre;'></p>

<br/><br/><br/>

<h2><u>Donations</u></h2>

<text>Any donations are appreciated!</text><br/><br/>
<text id="ID_DonateInputText">Amount (?):</text>
<input id="ID_DonateInput" type="text" maxlength="9"></input>
<button id="ID_DonateButton">Donate</button><br/>
<p id="ID_DonateResultText" style='white-space: pre;'></p>

<script type="module">
	import { ethers } from "./ethers-5.7.esm.min.js";
	
	let contractInterface;
	
	const HeaderText = document.querySelector('#ID_HeaderText');
	
	const ConnectButton = document.querySelector('#ID_ConnectButton');
	const ConnectAddressResultText = document.querySelector('#ID_ConnectAddressResultText');
	const ConnectAddressResultTable = document.querySelector('#ID_ConnectAddressResultTable');
	
	const UpdateMintDataButton = document.querySelector('#ID_UpdateMintDataButton');
	const UpdateMintDataResultText = document.querySelector('#ID_UpdateMintDataResultText');
	const MintButton = document.querySelector('#ID_MintButton');
	const MintResultText = document.querySelector('#ID_MintResultText');
	
	const XRadioColorMode0 = document.querySelector('#ID_XRadioColorMode0');
	const XRadioColorMode1 = document.querySelector('#ID_XRadioColorMode1');
	const XRadioColorMode2 = document.querySelector('#ID_XRadioColorMode2');
	const XRadioColorMode3 = document.querySelector('#ID_XRadioColorMode3');
	const XRadioColorMode4 = document.querySelector('#ID_XRadioColorMode4');
	const XRadioColorMode5 = document.querySelector('#ID_XRadioColorMode5');
	const XRadioColorMode6 = document.querySelector('#ID_XRadioColorMode6');
	const XRadioColorMode7 = document.querySelector('#ID_XRadioColorMode7');
	const XRadioColorMode8 = document.querySelector('#ID_XRadioColorMode8');
	const XRadioColorMode9 = document.querySelector('#ID_XRadioColorMode9');
	const XRadioColorMode10 = document.querySelector('#ID_XRadioColorMode10');
	const XRadioColorMode11 = document.querySelector('#ID_XRadioColorMode11');
	
	const XRadioDuration0 = document.querySelector('#ID_XRadioDuration0');
	const XRadioDuration1 = document.querySelector('#ID_XRadioDuration1');
	const XRadioDuration2 = document.querySelector('#ID_XRadioDuration2');
	
	const XRadioImageSize0 = document.querySelector('#ID_XRadioImageSize0');
	const XRadioImageSize1 = document.querySelector('#ID_XRadioImageSize1');
	const XRadioImageSize2 = document.querySelector('#ID_XRadioImageSize2');
	
	const ConfigIDInput = document.querySelector('#ID_ConfigIDInput');
	
	const RadioColorMode0 = document.querySelector('#ID_RadioColorMode0');
	const RadioColorMode1 = document.querySelector('#ID_RadioColorMode1');
	const RadioColorMode2 = document.querySelector('#ID_RadioColorMode2');
	const RadioColorMode3 = document.querySelector('#ID_RadioColorMode3');
	const RadioColorMode4 = document.querySelector('#ID_RadioColorMode4');
	const RadioColorMode5 = document.querySelector('#ID_RadioColorMode5');
	const RadioColorMode6 = document.querySelector('#ID_RadioColorMode6');
	const RadioColorMode7 = document.querySelector('#ID_RadioColorMode7');
	const RadioColorMode8 = document.querySelector('#ID_RadioColorMode8');
	const RadioColorMode9 = document.querySelector('#ID_RadioColorMode9');
	const RadioColorMode10 = document.querySelector('#ID_RadioColorMode10');
	const RadioColorMode11 = document.querySelector('#ID_RadioColorMode11');
	
	const RadioDuration0 = document.querySelector('#ID_RadioDuration0');
	const RadioDuration1 = document.querySelector('#ID_RadioDuration1');
	const RadioDuration2 = document.querySelector('#ID_RadioDuration2');
	
	const RadioImageSize0 = document.querySelector('#ID_RadioImageSize0');
	const RadioImageSize1 = document.querySelector('#ID_RadioImageSize1');
	const RadioImageSize2 = document.querySelector('#ID_RadioImageSize2');
	
	const SaveConfigButton = document.querySelector('#ID_SaveConfigButton');
	const SaveConfigResultText = document.querySelector('#ID_SaveConfigResultText');
	
	const NFTIDInput = document.querySelector('#ID_NFTIDInput');
	const NFTDisplayButton = document.querySelector('#ID_NFTDisplayButton');
	const NFTOwnerText = document.querySelector('#ID_NFTOwnerText');
	const NFTImage = document.querySelector('#ID_NFTImage');
	const NFTDisplayResultText = document.querySelector('#ID_NFTDisplayResultText');
	
	const DonateInputText = document.querySelector('#ID_DonateInputText');
	const DonateInput = document.querySelector('#ID_DonateInput');
	const DonateButton = document.querySelector('#ID_DonateButton');
	const DonateResultText = document.querySelector('#ID_DonateResultText');
	
	const BLACK = "#000000";
	const RED = "#B00000";
	const GREEN = "#00B000";
	const YELLOW = "#B0B000";
	
	const MAX_MINTS = 100;
	
	let INPROGRESS_MINT = false;
	let INPROGRESS_CHANGE = false;
	let INPROGRESS_DONATE = false;
	
	window.addEventListener('load', () => {
		async_onLoad();
	});
	
	async function async_onLoad() {
		HeaderText.innerHTML = "Pixel Prismatica NFT DApp (" + parent.getChainDisplayName() + ")";
		DonateInputText.innerHTML = "Amount (" + parent.getChainCoinName() + "):";
		
		// Do this to work around weird iframe behavior.
		let computedStyle = HeaderText.currentStyle || window.getComputedStyle(HeaderText);
		HeaderText.style.margin = computedStyle.margin;
		
		contractInterface = new ethers.utils.Interface(await parent.getContractJSON());
		
		async_updateWallet();
		async_updateMintData();
		
		let arr = getInjectedProvider();
		
		if(arr[1]) {
			arr[1].on('chainChanged', () => {
				window.location.reload();
			})
			arr[1].on('accountsChanged', () => {
				async_updateWallet();
			})
		}
	}
	
	async function async_updateWallet() {
		try {
			let arr = await getConnectedAddress(false);
			if(arr[0]) {
				ConnectAddressResultTable.innerHTML = "";
			
				ConnectAddressResultText.style.color = RED;
				ConnectAddressResultText.innerHTML = arr[0];
			}
			else {
				ConnectAddressResultText.style.color = YELLOW;
				ConnectAddressResultText.innerHTML = "";
				
				ConnectAddressResultTable.innerHTML = "";
				
				let T = document.createElement('text');
				T.innerHTML = "Address Connected: ";
				
				let A = document.createElement('a');
				A.innerHTML = arr[2];
				A.href = parent.getExplorerBaseUrl() + "address/" + arr[2];
				A.target = "_blank";
				
				ConnectAddressResultTable.appendChild(T);
				ConnectAddressResultTable.appendChild(A);
			}
		}
		catch(error) {
			ConnectAddressResultTable.innerHTML = "";
		
			ConnectAddressResultText.style.color = red;
			ConnectAddressResultText.innerHTML = getErrorString(error);
		}
	}

	ConnectButton.addEventListener('click', () => {
		async_connectWallet();
	});
	
	async function async_connectWallet() {
		try {
			let arr = getInjectedProvider();
			if(arr[0]) {
				ConnectAddressResultTable.innerHTML = "";
			
				ConnectAddressResultText.style.color = RED;
				ConnectAddressResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			
			ConnectAddressResultText.style.color = YELLOW;
			ConnectAddressResultText.innerHTML = "Connection in progress...";
		
			// Get permission from the user via the wallet application. This will always ask the user, even if they are already connected.
			await eth_request(injectedProvider, "wallet_requestPermissions", [{"eth_accounts": {}}]);
			
			async_updateWallet();
		}
		catch(error) {
			ConnectAddressResultTable.innerHTML = "";
		
			ConnectAddressResultText.style.color = RED;
			ConnectAddressResultText.innerHTML = getErrorString(error);
		}
	}
	
	UpdateMintDataButton.addEventListener('click', () => {
		async_updateMintData();
	});
	
	async function async_updateMintData() {
		try {
			let arr = getInjectedProvider();
			if(arr[0]) {
				UpdateMintDataResultText.style.color = RED;
				UpdateMintDataResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			
			UpdateMintDataResultText.style.color = YELLOW;
			UpdateMintDataResultText.innerHTML = "Updating Mint Data...";
			
			let promiseArray = [];
			promiseArray.push(contractReadCall(injectedProvider, "get_totalMints", []));
			promiseArray.push(contractReadCall(injectedProvider, "get_mintFee", []));
			
			let resultArray = await Promise.allSettled(promiseArray);
			
			let totalMints = resultArray[0].status == "fulfilled" ? resultArray[0].value : undefined;
			let mintFee = resultArray[1].status == "fulfilled" ? resultArray[1].value : undefined;
			
			if(Number(totalMints) == MAX_MINTS) {
				let totalMintsText = "Next ID: " + (totalMints ? + (Number(totalMints) + 1) : promiseError);
				let mintFeeText = "Next Mint Fee: " + (mintFee ? + ethers.utils.formatEther(mintFee) : promiseError);
				
				UpdateMintDataResultText.style.color = RED;
				UpdateMintDataResultText.innerHTML = "All 100 NFTs on this network have been minted.";
			}
			else {
				const promiseError = "(Cannot Find Data)";
				let totalMintsText = "Next ID: " + (totalMints ? + (Number(totalMints) + 1) : promiseError);
				let mintFeeText = "Next Mint Fee: " + (mintFee ? + ethers.utils.formatEther(mintFee) : promiseError);
				
				UpdateMintDataResultText.style.color = BLACK;
				UpdateMintDataResultText.innerHTML = totalMintsText + "&nbsp;&nbsp;&nbsp;" + mintFeeText + "&nbsp;";
			}
		}
		catch(error) {
			UpdateMintDataResultText.style.color = RED;
			UpdateMintDataResultText.innerHTML = getErrorString(error);
		}
	}
	
	MintButton.addEventListener('click', () => {
		async_mint();
	});
	
	async function async_mint() {
		try {
			let arr = await getConnectedAddress(true);
			if(arr[0]) {
				MintResultText.style.color = RED;
				MintResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			let address = arr[2];
			
			MintResultText.style.color = YELLOW;
			MintResultText.innerHTML = "Mint in progress...";
			
			if(INPROGRESS_MINT) {
				return;
			}
			
			INPROGRESS_MINT = true;
			
			// When the user clicks mint, update the mint data so the user can see the most recent values.
			async_updateMintData();
			
			let totalMints = await contractReadCall(injectedProvider, "get_totalMints", []);
			
			if(Number(totalMints) == MAX_MINTS) {
				MintResultText.style.color = RED;
				MintResultText.innerHTML = "There are no more NFTs available to mint on this network.";
			}
			else {
				let colorMode = getXColorMode();
				let duration = getXDuration();
				let imageSize = getXImageSize();
				let data = 0; // This value is not important.
				
				let mintFee = await contractReadCall(injectedProvider, "get_mintFee", []);
				await contractWriteCall(injectedProvider, "action_mint", [colorMode, duration, imageSize, data, {value: mintFee}]);
					
				MintResultText.style.color = GREEN;
				MintResultText.innerHTML = "Mint Complete.";
			}
		}
		catch(error) {
			MintResultText.style.color = RED;
			MintResultText.innerHTML = getErrorString(error);
		}
		
		// Regardless of outcome, update the mint data again.
		async_updateMintData();
		
		INPROGRESS_MINT = false;
	}
	
	SaveConfigButton.addEventListener('click', () => {
		async_saveConfig();
	});

	async function async_saveConfig() {
		try {
			let arr = await getConnectedAddress(true);
			if(arr[0]) {
				SaveConfigResultText.style.color = RED;
				SaveConfigResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			let address = arr[2];
			
			SaveConfigResultText.style.color = YELLOW;
			SaveConfigResultText.innerHTML = "Save in progress...";
			
			let inputString = ConfigIDInput.value;
			let id = Number(inputString);
			
			if(!Number.isInteger(id)) {
				SaveConfigResultText.style.color = RED;
				SaveConfigResultText.innerHTML = "You must enter an integer NFT ID.";
			}
			else if(id <= 0 || id > 100) {
				SaveConfigResultText.style.color = RED;
				SaveConfigResultText.innerHTML = "NFT ID must be between 1 and 100.";
			}
			else {
				let nftOwner = await contractReadCall(injectedProvider, "get_nftOwner", [id]);
				
				if(nftOwner.toLowerCase() != address.toLowerCase()) {
					SaveConfigResultText.style.color = RED;
					SaveConfigResultText.innerHTML = "Connected address does not own this NFT.";
				}
				else {
					let colorMode = getColorMode();
					let duration = getDuration();
					let imageSize = getImageSize();
					
					await contractWriteCall(injectedProvider, "action_applyConfig", [id, colorMode, duration, imageSize]);
				
					SaveConfigResultText.style.color = GREEN;
					SaveConfigResultText.innerHTML = "Save Complete.";
				}
			}
		}
		catch(error) {
			SaveConfigResultText.style.color = RED;
			SaveConfigResultText.innerHTML = getErrorString(error);
		}
	}
	
	function getXColorMode() {
		let colorMode;
		if(XRadioColorMode0.checked) {
			colorMode = 0;
		}
		else if(XRadioColorMode1.checked) {
			colorMode = 1;
		}
		else if(XRadioColorMode2.checked) {
			colorMode = 2;
		}
		else if(XRadioColorMode3.checked) {
			colorMode = 3;
		}
		else if(XRadioColorMode4.checked) {
			colorMode = 4;
		}
		else if(XRadioColorMode5.checked) {
			colorMode = 5;
		}
		else if(XRadioColorMode6.checked) {
			colorMode = 6;
		}
		else if(XRadioColorMode7.checked) {
			colorMode = 7;
		}
		else if(XRadioColorMode8.checked) {
			colorMode = 8;
		}
		else if(XRadioColorMode9.checked) {
			colorMode = 9;
		}
		else if(XRadioColorMode10.checked) {
			colorMode = 10;
		}
		else if(XRadioColorMode11.checked) {
			colorMode = 11;
		}
		else {
			// Default to 0
			colorMode = 0;
		}
		return colorMode;
	}
	
	function getXDuration() {
		let duration;
		if(XRadioDuration0.checked) {
			duration = 0;
		}
		else if(XRadioDuration1.checked) {
			duration = 1;
		}
		else if(XRadioDuration2.checked) {
			duration = 2;
		}
		else {
			// Default to 1
			duration = 1;
		}
		return duration;
	}
	
	function getXImageSize() {
		let imageSize;
		if(XRadioImageSize0.checked) {
			imageSize = 0;
		}
		else if(XRadioImageSize1.checked) {
			imageSize = 1;
		}
		else if(XRadioImageSize2.checked) {
			imageSize = 2;
		}
		else {
			// Default to 1
			imageSize = 1;
		}
		return imageSize;
	}
	
	function getColorMode() {
		let colorMode;
		if(RadioColorMode0.checked) {
			colorMode = 0;
		}
		else if(RadioColorMode1.checked) {
			colorMode = 1;
		}
		else if(RadioColorMode2.checked) {
			colorMode = 2;
		}
		else if(RadioColorMode3.checked) {
			colorMode = 3;
		}
		else if(RadioColorMode4.checked) {
			colorMode = 4;
		}
		else if(RadioColorMode5.checked) {
			colorMode = 5;
		}
		else if(RadioColorMode6.checked) {
			colorMode = 6;
		}
		else if(RadioColorMode7.checked) {
			colorMode = 7;
		}
		else if(RadioColorMode8.checked) {
			colorMode = 8;
		}
		else if(RadioColorMode9.checked) {
			colorMode = 9;
		}
		else if(RadioColorMode10.checked) {
			colorMode = 10;
		}
		else if(RadioColorMode11.checked) {
			colorMode = 11;
		}
		else {
			// Default to 0
			colorMode = 0;
		}
		return colorMode;
	}
	
	function getDuration() {
		let duration;
		if(RadioDuration0.checked) {
			duration = 0;
		}
		else if(RadioDuration1.checked) {
			duration = 1;
		}
		else if(RadioDuration2.checked) {
			duration = 2;
		}
		else {
			// Default to 1
			duration = 1;
		}
		return duration;
	}
	
	function getImageSize() {
		let imageSize;
		if(RadioImageSize0.checked) {
			imageSize = 0;
		}
		else if(RadioImageSize1.checked) {
			imageSize = 1;
		}
		else if(RadioImageSize2.checked) {
			imageSize = 2;
		}
		else {
			// Default to 1
			imageSize = 1;
		}
		return imageSize;
	}

	NFTDisplayButton.addEventListener('click', () => {
		async_displayNFT();
	});

	async function async_displayNFT() {
		try {
			let arr = await getConnectedAddress(true);
			if(arr[0]) {
				NFTDisplayResultText.style.color = RED;
				NFTDisplayResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			let address = arr[2];
			
			NFTOwnerText.innerHTML = "";
			NFTImage.src = "";
			NFTDisplayResultText.style.color = YELLOW;
			NFTDisplayResultText.innerHTML = "NFT Drawing in progress...";
			
			let inputString = NFTIDInput.value;
			let id = Number(inputString);
			
			if(!Number.isInteger(id)) {
				NFTDisplayResultText.style.color = RED;
				NFTDisplayResultText.innerHTML = "You must enter an integer NFT ID.";
			}
			else if(id <= 0 || id > 100) {
				NFTDisplayResultText.style.color = RED;
				NFTDisplayResultText.innerHTML = "NFT ID must be between 1 and 100.";
			}
			else {
				let nftOwner = await contractReadCall(injectedProvider, "get_nftOwner", [id]);
				if(isZeroAddress(nftOwner)) {
					NFTOwnerText.innerHTML = "(Unminted)";
				}
				else {
					NFTOwnerText.innerHTML = "Owner: " + nftOwner;
				}
				
				if(nftOwner.toLowerCase() != address.toLowerCase()) {
					NFTDisplayResultText.style.color = RED;
					NFTDisplayResultText.innerHTML = "Connected address does not own this NFT.";
				}
				else {
					let imageURI = await contractReadCall(injectedProvider, "get_imageURI", [id]);
					let imageName = await contractReadCall(injectedProvider, "createName", [id]);
					let imageDescription = await contractReadCall(injectedProvider, "createDescription", [id]);
					
					NFTImage.src = imageURI;
				
					NFTDisplayResultText.style.color = GREEN;
					NFTDisplayResultText.innerHTML = imageName + "\n" + imageDescription;
				}
			}
		}
		catch(error) {
			NFTImage.src = "";
			NFTDisplayResultText.style.color = RED;
			NFTDisplayResultText.innerHTML = getErrorString(error);
		}
	}
	
	DonateButton.addEventListener('click', () => {
		async_donateButton();
	});
	
	async function async_donateButton() {
		try {
			let arr = await getConnectedAddress(true);
			if(arr[0]) {
				DonateResultText.style.color = RED;
				DonateResultText.innerHTML = arr[0];
				return;
			}
			
			let injectedProvider = arr[1];
			let address = arr[2];
			
			DonateResultText.style.color = YELLOW;
			DonateResultText.innerHTML = "Donation in progress...";
		
			let inputString = DonateInput.value;
			let donationValue = Number(inputString);
			
			if(!Number.isFinite(donationValue)) {
				DonateResultText.style.color = RED;
				DonateResultText.innerHTML = "You must enter a valid amount to donate.";
			}
			else if(donationValue <= 0) {
				DonateResultText.style.color = RED;
				DonateResultText.innerHTML = "The donation amount must be greater than 0.";
			}
			else {
				let donationValueETH = ethers.utils.parseEther(inputString);
				let addressBalance = await getAddressBalance(injectedProvider, address);
				
				if(ethers.BigNumber.from(addressBalance).lt(ethers.BigNumber.from(donationValueETH))) {
					DonateResultText.style.color = RED;
					DonateResultText.innerHTML = "Connected address has insufficient balance to donate.\nBalance = " + ethers.utils.formatEther(addressBalance) + " " + parent.getChainCoinName();
				}
				else {
					await contractWriteCall(injectedProvider, "donate", [{value: donationValueETH}]);
				
					DonateResultText.style.color = GREEN;
					DonateResultText.innerHTML = "Donation complete.";
				}
			}
		}
		catch(error) {
			DonateResultText.style.color = RED;
			DonateResultText.innerHTML = getErrorString(error);
		}
	}
			
	// Util Functions
	function isZeroAddress(address) {
		return "0x0000000000000000000000000000000000000000" == address;
	}
	
	async function getAddressBalance(injectedProvider, address) {
		// Returns balance in Wei. Make sure we convert hex to decimal before returning.
		return String(parseInt(await injectedProvider.request({"method": "eth_getBalance", "params": [address]}), 16));
	}
	
	async function eth_request(injectedProvider, method, params) {
		return await injectedProvider.request({"method": method, "params": params});
	}
	
	async function contractReadCall(injectedProvider, method, args) {
		const provider = new ethers.providers.Web3Provider(injectedProvider, new ethers.providers.getNetwork(parent.getChainID()));
		const contractRead = new ethers.Contract(parent.getContractAddress(), contractInterface, provider);
		return await contractRead[method](...args);
	}
	
	async function contractWriteCall(injectedProvider, method, args) {
		const provider = new ethers.providers.Web3Provider(injectedProvider, new ethers.providers.getNetwork(parent.getChainID()));
		
		// Get permission from the user via the wallet application. This only asks the user if they are not already connected.
		await eth_request(injectedProvider, "eth_requestAccounts", []);
		
		const signer = provider.getSigner();
		const contractWrite = new ethers.Contract(parent.getContractAddress(), contractInterface, signer);
		
		let call = await contractWrite[method](...args);
		await call.wait();
	}
	
	function getNetworkString(network) {
		let networkString = undefined;
		
		if(network) {
			networkString = network.name + " (chain id: " + network.chainId + ")"; 
		}
		
		return networkString;
	}
	
	function getInjectedProvider() {
		// Returns a Web3 injection if present and on the correct network, otherwise return an error.
		let errorString = undefined;
		let injectedProvider = undefined;
		
		try {
			// This is only available on the parent.
			injectedProvider = window.parent.ethereum;
			
			if(injectedProvider == undefined) {
				errorString = "A Web3 wallet is not present.";
			}
			else if(!injectedProvider.isConnected()) {
				errorString = "A Web3 wallet is present, but it is not connected to the blockchain.";
			}
			else if(injectedProvider.networkVersion != parent.getChainID()) {
				let actualNetwork = ethers.providers.getNetwork(Number(injectedProvider.networkVersion));
				let expectedNetwork = ethers.providers.getNetwork(parent.getChainID());
				errorString = "A Web3 wallet is connected, but it is on the wrong network.\n" + 
				"    Actual Network: " + getNetworkString(actualNetwork) + "\n" + 
				"    Expected Network: " + getNetworkString(expectedNetwork);
			}
		}
		catch(error) {
			errorString = "Unknown Error.\n\n" + error;
			injectedProvider = undefined;
			logError("Error", error);
		}
		
		return [errorString, injectedProvider]
	}
	
	async function getConnectedAddress(askForConnection) {
		// Return an address if the Web3 injection is present, on the correct network, and there is exactly one connected address, otherwise return an error.
		let errorString = undefined;
		let injectedProvider = undefined;
		let address = undefined;
		
		try {
			let arr = getInjectedProvider();
			if(arr[0]) {
				errorString = arr[0];
				return [errorString, injectedProvider, address];
			}
			
			injectedProvider = arr[1];
			
			if(askForConnection) {
				await eth_request(injectedProvider, "eth_requestAccounts", []);
			}
		
			let connectedAddressArray = await eth_request(injectedProvider, "eth_accounts", []);
			if(connectedAddressArray.length == 0) {
				errorString = "A Web3 wallet is connected, but no addresses are connected to this dapp.";
			}
			else if(connectedAddressArray.length > 1) {
				errorString = "A Web3 wallet is connected, but multiple addresses are connected to this dapp. Only a single address can be connected to this dapp at once.";
			}
			else {
				address = connectedAddressArray[0];
			}
		}
		catch(error) {
			errorString = getErrorString(error);
			injectedProvider = undefined;
			address = undefined;
		}
		
		return [errorString, injectedProvider, address];
	}
	
	function getErrorString(error) {
		try {
			if(error && error.error && error.error.data && error.error.data.data && canParseSmartContractErrorData(error.error.data.data)) {
				// Write error.
				let errorDescription = parseSmartContractErrorData(error.error.data.data);
				let errString = "Smart Contract Error: " + errorDescription.name;
				let errorArgs = errorDescription.args;
				for(let key in errorArgs) {
					// Filter out the numeric indices to avoid printing the same values twice.
					if(isNaN(key)) {
						errString = errString + "\n    " + key + ": " + errorArgs[key];
					}
				}
				
				return errString;
			}
			else if(error && error.data && canParseSmartContractErrorData(error.data)) {
				// Read error.
				let errorDescription = parseSmartContractErrorData(error.data);
				let errString = "Smart Contract Error: " + errorDescription.name;
				let errorArgs = errorDescription.args;
				for(let key in errorArgs) {
					// Filter out the numeric indices to avoid printing the same values twice.
					if(isNaN(key)) {
						errString = errString + "\n    " + key + ": " + errorArgs[key];
					}
				}
				
				return errString;
			}
			else if(error && error.code == "ACTION_REJECTED") {
				// Transaction canceled.
				return "The transaction was canceled.";
			}
			else if(error && error.code == "UNPREDICTABLE_GAS_LIMIT") {
				// Cannot estimate gas.
				return "Cannot estimate gas for the transaction.";
			}
			else if(error && error.code == "CALL_EXCEPTION") {
				// The call either ran out of gas or ran into another problem.
				return "The transaction failed.";
			}
			else if(error && error.code == "UNSUPPORTED_OPERATION") {
				// The wallet was disconnected but an operation was still attempted.
				return "The operation was not supported. Make sure your wallet is connected to the dapp.";
			}
			else if(error && error.code == 4001) {
				// Connection canceled.
				return "The connection was canceled.";
			}
			else if(error && error.code == -32002) {
				return error.message;
			}
			else if(error && error.code == -32603) {
				// Internal JSON-RPC error. Examples: Insufficient funds for the transaction. Exceed maximum block range: 5000.
				return error.message + "\n" + error.data.message;
			}
			else {
				// Just give up.
				logError("Error", error);
				
				return "Unknown Error.\n\n" + error;
			}
		}
		catch(error2) {
			// Just give up.
			logError("Error 1", error);
			logError("Error 2", error2);
			
			return "Unknown Error 1.\n\n" + error + "\n\nUnknown Error 2.\n\n" + error2;
		}
	}
	
	function logError(labelStr, errorObject) {
		console.error(labelStr + ":\n\n" + JSON.stringify(errorObject, Object.getOwnPropertyNames(errorObject), 4));
	}
	
	function canParseSmartContractErrorData(errorData) {
		try {
			parseSmartContractErrorData(errorData);
			return true;
		}
		catch {
			return false;
		}
	}
	
	function parseSmartContractErrorData(errorData) {
		if (errorData.startsWith('0x08c379a0')) { // decode Error(string)
			const content = `0x${errorData.substring(10)}`;
			const reason = utils.defaultAbiCoder.decode(["string"], content);

			return reason[0]; // reason: string; for standard revert error string
		}

		if (errorData.startsWith('0x4e487b71')) { // decode Panic(uint)
			const content = `0x${errorData.substring(10)}`;
			const code = utils.defaultAbiCoder.decode(["uint"], content);

			return code[0];
		}
	
		return contractInterface.parseError(errorData);
	}
</script>